"""
Pydantic models for API requests.
These define the contract between the API and external clients.

Following clean architecture principles, request models delegate validation
to domain model class methods and reuse field descriptions to avoid
duplication while maintaining single source of truth in the domain layer.
"""

from typing import Dict, Any
from pydantic import BaseModel, Field, field_validator
from datetime import datetime, timezone

from julee_example.domain.models.assembly_specification import (
    assembly_specification,
)

AssemblySpecification = assembly_specification.AssemblySpecification
AssemblySpecificationStatus = (
    assembly_specification.AssemblySpecificationStatus
)


class CreateAssemblySpecificationRequest(BaseModel):
    """Request model for creating an assembly specification.

    This model defines what clients need to provide when creating a new
    assembly specification. Validation logic is delegated to the domain
    model to ensure consistency and avoid duplication.

    Fields excluded from client control:
    - assembly_specification_id: Always generated by the server
    - status: Always set to DRAFT initially by the server
    - created_at/updated_at: System-managed timestamps
    """

    # Field definitions with descriptions reused from domain model
    name: str = Field(
        description=AssemblySpecification.model_fields["name"].description
    )
    applicability: str = Field(
        description=AssemblySpecification.model_fields[
            "applicability"
        ].description
    )
    jsonschema: Dict[str, Any] = Field(
        description=AssemblySpecification.model_fields[
            "jsonschema"
        ].description
    )
    knowledge_service_queries: Dict[str, str] = Field(
        default_factory=dict,
        description=AssemblySpecification.model_fields[
            "knowledge_service_queries"
        ].description,
    )
    version: str = Field(
        default="0.1.0",
        description=AssemblySpecification.model_fields["version"].description,
    )

    # Delegate validation to domain model class methods
    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        return AssemblySpecification.name_must_not_be_empty(v)

    @field_validator("applicability")
    @classmethod
    def validate_applicability(cls, v: str) -> str:
        return AssemblySpecification.applicability_must_not_be_empty(v)

    @field_validator("jsonschema")
    @classmethod
    def validate_jsonschema(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        return AssemblySpecification.jsonschema_must_be_valid(v)

    @field_validator("knowledge_service_queries")
    @classmethod
    def validate_knowledge_service_queries(
        cls, v: Dict[str, str], info: Any
    ) -> Dict[str, str]:
        return AssemblySpecification.knowledge_service_queries_must_be_valid(
            v, info
        )

    @field_validator("version")
    @classmethod
    def validate_version(cls, v: str) -> str:
        return AssemblySpecification.version_must_not_be_empty(v)

    def to_domain_model(
        self, assembly_specification_id: str
    ) -> AssemblySpecification:
        """Convert this request to a complete AssemblySpecification object.

        Args:
            assembly_specification_id: The ID to assign to the new spec

        Returns:
            AssemblySpecification: Complete domain object with system fields
        """
        return AssemblySpecification(
            assembly_specification_id=assembly_specification_id,
            name=self.name,
            applicability=self.applicability,
            jsonschema=self.jsonschema,
            knowledge_service_queries=self.knowledge_service_queries,
            version=self.version,
            status=AssemblySpecificationStatus.DRAFT,
            created_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc),
        )
